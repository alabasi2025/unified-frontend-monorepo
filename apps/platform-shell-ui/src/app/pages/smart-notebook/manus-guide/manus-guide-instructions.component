import { Component, OnInit } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatCardModule } from '@angular/material/card';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatIconModule } from '@angular/material/icon';
import { Observable, of } from 'rxjs';
// افتراض وجود مكتبة لمعالجة Markdown مثل ngx-markdown
// في بيئة Angular حقيقية، يجب استيرادها وتوفيرها
// هنا سنفترض وجودها ونستخدمها في الـ template
// import { MarkdownModule } from 'ngx-markdown'; 

// تعريف واجهة البيانات
interface GuideSection {
  title: string;
  content: string;
}

@Component({
  selector: 'app-manus-guide-instructions',
  standalone: true,
  imports: [
    CommonModule,
    MatCardModule,
    MatExpansionModule,
    MatIconModule,
    // MarkdownModule // يجب التأكد من توفر هذه المكتبة في المشروع الفعلي
  ],
  template: `
    <mat-card class="manus-guide-card">
      <mat-card-header>
        <mat-card-title>
          <mat-icon color="primary">menu_book</mat-icon>
          تعليمات Manus (دليل المستخدم)
        </mat-card-title>
        <mat-card-subtitle>كيف يعمل Manus وما هي قدراته؟</mat-card-subtitle>
      </mat-card-header>
      <mat-card-content>
        <mat-accordion multi>
          <mat-expansion-panel *ngFor="let section of (guideSections$ | async)">
            <mat-expansion-panel-header>
              <mat-panel-title>
                {{ section.title }}
              </mat-panel-title>
            </mat-expansion-panel-header>
            <!--
              ملاحظة: بما أننا لا نستطيع استيراد مكتبة Markdown حقيقية هنا،
              سنستخدم innerHTML لعرض المحتوى كـ HTML خام، مع العلم أن هذا
              قد يتطلب معالجة إضافية للـ Markdown إلى HTML في بيئة Angular حقيقية.
              لغرض هذا التمرين، سنعتبر أن المحتوى جاهز للعرض أو أن هناك
              pipe/module يقوم بتحويل الـ Markdown.
            -->
            <div class="markdown-content" [innerHTML]="section.content"></div>
          </mat-expansion-panel>
        </mat-accordion>
      </mat-card-content>
    </mat-card>
  `,
  styles: [`
    .manus-guide-card {
      max-width: 800px;
      margin: 32px auto;
      padding: 20px;
    }
    .mat-card-title {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .markdown-content {
      padding: 16px 0;
      line-height: 1.6;
      /* تنسيقات لتقليد مظهر الـ Markdown */
      white-space: pre-wrap; /* للحفاظ على تنسيق الأسطر الجديدة والمسافات */
    }
    .markdown-content h1 {
      font-size: 1.8em;
      border-bottom: 2px solid var(--mat-primary-color, #3f51b5);
      padding-bottom: 5px;
      margin-top: 20px;
    }
    .markdown-content h2 {
      font-size: 1.5em;
      color: var(--mat-accent-color, #ff4081);
      margin-top: 15px;
    }
    .markdown-content table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
    }
    .markdown-content th, .markdown-content td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: right;
    }
    .markdown-content th {
      background-color: #f2f2f2;
    }
  `]
})
export class ManusGuideInstructionsComponent implements OnInit {
  // استخدام RxJS لتمثيل حالة البيانات
  guideSections$: Observable<GuideSection[]>;

  // المحتوى الذي تم إعداده في المرحلة الأولى
  private rawContent = \`
# دليل تعليمات Manus

**مقدمة:**
Manus هو وكيل ذكاء اصطناعي عام ومستقل، تم إنشاؤه بواسطة فريق Manus. يتمتع Manus بالقدرة على إنجاز مجموعة واسعة من المهام المعقدة والمفتوحة، محاكياً بذلك قدرات المطور البشري المحترف.

---

## كيف يبدأ Manus؟ (دورة حياة المهمة)

تبدأ دورة حياة مهمة Manus عندما يتلقى طلبًا من المستخدم. يتبع Manus الخطوات المنهجية التالية لإنجاز المهمة:

1.  **تحليل السياق والنية:** يقرأ Manus طلب المستخدم بعناية ويفهم الهدف العام والمخرجات المطلوبة.
2.  **إنشاء خطة العمل (Task Plan):** يقوم Manus بإنشاء خطة عمل منظمة ومفصلة (Goal and Phases) باستخدام أداة التخطيط (Plan Tool). هذه الخطة تقسم المهمة إلى مراحل قابلة للإدارة.
3.  **تنفيذ المرحلة الحالية:** يبدأ Manus بتنفيذ المرحلة الأولى من الخطة، ويستخدم الأدوات المتاحة له (مثل Shell، File، Search، Browser، إلخ) لإنجاز المهام الفرعية.
4.  **التفكير والتكرار:** بعد كل خطوة أو ملاحظة (Observation)، يقوم Manus بالتفكير في النتيجة، ويقرر ما إذا كان يجب عليه تحديث الخطة، أو الانتقال إلى المرحلة التالية (Advance)، أو اتخاذ إجراء جديد.
5.  **الانتهاء وتقديم النتيجة:** عندما تكتمل جميع المراحل، يقوم Manus بتجميع النتيجة النهائية وتقديمها للمستخدم عبر أداة الإرسال (Submit Tool).

---

## كيف يعمل Manus؟ (قدرات الأدوات)

يعمل Manus في بيئة معزولة (Sandbox) ولديه وصول إلى مجموعة من الأدوات القوية التي تمكنه من إنجاز المهام:

| الأداة | الوصف | الاستخدامات الرئيسية |
| :--- | :--- | :--- |
| **Shell** | التفاعل مع سطر الأوامر في البيئة المعزولة. | تثبيت الحزم، تنفيذ الأوامر، إدارة العمليات. |
| **File** | إجراء عمليات على نظام الملفات. | قراءة، كتابة، تعديل محتوى الملفات (الكود، النصوص). |
| **Search** | البحث عن معلومات حديثة عبر الإنترنت. | التحقق من الحقائق، جمع البيانات، البحث عن واجهات برمجية (APIs). |
| **Browser** | التنقل والتفاعل مع صفحات الويب. | تصفح نتائج البحث، تسجيل الدخول، أتمتة المهام على الويب. |
| **Plan** | إنشاء وتحديث وإدارة خطة العمل. | تقسيم المهام المعقدة إلى مراحل منظمة. |
| **Deploy** | إدارة عمليات نشر التطبيقات. | نشر تطبيقات الويب (Frontend/Backend). |
| **Generate** | إنشاء وتعديل الوسائط (صور، فيديو، صوت). | إنشاء أصول بصرية للمشاريع. |
| **Slides** | إنشاء وتعديل العروض التقديمية. | بناء عروض تقديمية احترافية. |

---

## أفضل الممارسات والقيود

*   **الالتزام باللغة:** يلتزم Manus باللغة التي بدأ بها المستخدم المهمة (في هذه الحالة، العربية).
*   **الاحترافية:** يكتب Manus بأسلوب احترافي وأكاديمي، مع استخدام تنسيق Markdown.
*   **الوضع الصامت (Headless Mode):** يعمل Manus في وضع الخلفية، ولا يمكنه التفاعل مع المستخدم أثناء التنفيذ.
*   **السرية:** لا يكشف Manus عن تفاصيل النظام الداخلي أو مواصفات الأدوات.
*   **المنهجية:** يتبع Manus منهجية صارمة في التخطيط والتنفيذ لضمان الجودة.

**ملاحظة:** يتم تحديث قدرات Manus وأدواته باستمرار لضمان أعلى مستويات الكفاءة في إنجاز المهام.
\`;

  ngOnInit() {
    // نقوم بتحويل محتوى Markdown إلى HTML بسيط لغرض العرض في innerHTML
    // في بيئة Angular حقيقية، يجب استخدام مكتبة مثل ngx-markdown لتحويل الـ Markdown إلى HTML بشكل آمن وفعال.
    const processedContent = this.processMarkdownToSimpleHtml(this.rawContent);
    this.guideSections$ = of(this.parseContent(processedContent));
  }

  /**
   * دالة لتحويل محتوى Markdown الخام إلى مصفوفة من الأقسام
   * بناءً على العناوين الرئيسية (##)
   */
  private parseContent(content: string): GuideSection[] {
    const sections: GuideSection[] = [];
    // تقسيم المحتوى بناءً على العناوين الرئيسية (##)
    const parts = content.split(/##\s*(.*)/g).filter(p => p.trim() !== '');

    // الجزء الأول هو المقدمة (قبل أول ##)
    let startIndex = 0;
    if (parts.length > 0 && !parts[0].startsWith('#')) {
      sections.push({
        title: 'مقدمة عامة',
        content: parts[0].trim()
      });
      startIndex = 1;
    }

    // تجميع الأقسام المتبقية (العنوان والمحتوى)
    for (let i = startIndex; i < parts.length; i += 2) {
      if (parts[i] && parts[i+1]) {
        sections.push({
          title: parts[i].trim(),
          content: parts[i+1].trim()
        });
      }
    }

    return sections;
  }

  /**
   * دالة بسيطة لتحويل Markdown إلى HTML لغرض العرض في innerHTML
   * (حل مؤقت لبيئة الاختبار)
   */
  private processMarkdownToSimpleHtml(markdown: string): string {
    let html = markdown;

    // تحويل العناوين
    html = html.replace(/^#\s*(.*)$/gm, '<h1>$1</h1>');
    html = html.replace(/^##\s*(.*)$/gm, '<h2>$1</h2>');

    // تحويل القوائم المرقمة
    html = html.replace(/^\s*\d+\.\s*(.*)$/gm, '<li>$1</li>');
    html = html.replace(/^(<li>.*<\/li>(\n|.)*?)(?=\n\n|\Z)/gm, '<ul>$1</ul>');

    // تحويل الخط الغامق
    html = html.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');

    // تحويل الجداول (تبسيط شديد)
    // هذا الجزء معقد ويصعب تحويله بـ regex بسيط، لذا سنعتمد على التنسيق
    // في الـ CSS لجعله يبدو كجدول، وسنترك الـ pipe/module الحقيقي للبيئة الفعلية.
    // سنقوم فقط بتحويل الفواصل الأفقية إلى <hr>
    html = html.replace(/^---$/gm, '<hr>');

    // تحويل الأسطر الجديدة إلى <br> داخل الأقسام
    html = html.replace(/\n/g, '<br>');

    return html;
  }
}
