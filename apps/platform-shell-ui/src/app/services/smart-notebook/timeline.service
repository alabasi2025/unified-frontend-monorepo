import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { BehaviorSubject, Observable, throwError } from 'rxjs';
import { catchError, tap, filter, map } from 'rxjs/operators';

// تعريف واجهات البيانات (يفترض وجودها لتطبيق TypeScript بشكل صحيح)
// لغرض هذا المثال، سنستخدم 'any' لتبسيط الكود، ولكن يفضل استخدام واجهات محددة.
interface TimelineEvent {
  id: string;
  entityId: string;
  timestamp: Date;
  description: string;
  // ... خصائص أخرى
}

@Injectable({
  providedIn: 'root'
})
export class TimelineService {
  private apiUrl = '/api/timeline/events';
  // BehaviorSubject لإدارة حالة الأحداث وتوفير تحديثات في الوقت الفعلي (Real-time simulation)
  private eventsSubject = new BehaviorSubject<TimelineEvent[]>([]);
  // Observable عام يمكن للمكونات الاشتراك فيه
  public events$: Observable<TimelineEvent[]> = this.eventsSubject.asObservable();

  constructor(private http: HttpClient) {
    // يمكن هنا تهيئة اتصال WebSocket/SignalR للحصول على تحديثات حقيقية
    // ولكن سنكتفي بـ BehaviorSubject كآلية لإدارة الحالة والتحديثات
  }

  /**
   * معالج الأخطاء المركزي لعمليات الـ HTTP
   * @param error - كائن الخطأ
   * @returns Observable يحتوي على خطأ
   */
  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'An unknown error occurred!';
    if (error.error instanceof ErrorEvent) {
      // خطأ من جانب العميل أو الشبكة
      errorMessage = `Error: ${error.error.message}`;
    } else {
      // خطأ من جانب الخادم
      errorMessage = `Server returned code: ${error.status}, error message: ${error.message}`;
    }
    console.error(errorMessage);
    // إرجاع Observable يحتوي على رسالة خطأ للمكون الذي استدعى الخدمة
    return throwError(() => new Error(errorMessage));
  }

  /**
   * جلب جميع أحداث الخط الزمني
   * @returns Observable من مصفوفة أحداث الخط الزمني
   */
  getAll(): Observable<TimelineEvent[]> {
    return this.http.get<TimelineEvent[]>(this.apiUrl).pipe(
      tap(data => this.eventsSubject.next(data)),
      catchError(this.handleError)
    );
  }

  /**
   * تصفية أحداث الخط الزمني بناءً على معايير محددة
   * @param criteria - معايير التصفية (مثلاً: { type: 'note', dateFrom: '...' })
   * @returns Observable من مصفوفة أحداث الخط الزمني المصفاة
   */
  filter(criteria: any): Observable<TimelineEvent[]> {
    // يمكن استخدام params لتمرير معايير التصفية إلى الـ API
    return this.http.get<TimelineEvent[]>(`${this.apiUrl}/filter`, { params: criteria }).pipe(
      // لا نقوم بتحديث الـ BehaviorSubject هنا إلا إذا كانت التصفية شاملة
      // في هذا المثال، سنفترض أن التصفية لا تغير الحالة العامة
      catchError(this.handleError)
    );
  }

  /**
   * جلب أحداث الخط الزمني لكيان محدد
   * @param entityId - معرف الكيان
   * @returns Observable من مصفوفة أحداث الخط الزمني للكيان
   */
  getByEntity(entityId: string): Observable<TimelineEvent[]> {
    return this.http.get<TimelineEvent[]>(`${this.apiUrl}/entity/${entityId}`).pipe(
      // يمكن تحديث الـ BehaviorSubject هنا ببيانات الكيان فقط إذا كان هذا هو السياق الرئيسي
      // لكن الأفضل ترك الـ BehaviorSubject للحالة العامة أو التحديثات في الوقت الفعلي
      catchError(this.handleError)
    );
  }

  /**
   * إنشاء حدث جديد في الخط الزمني
   * @param event - بيانات الحدث الجديد
   * @returns Observable من الحدث الذي تم إنشاؤه
   */
  createEvent(event: Omit<TimelineEvent, 'id' | 'timestamp'>): Observable<TimelineEvent> {
    return this.http.post<TimelineEvent>(this.apiUrl, event).pipe(
      tap(newEvent => {
        // تحديث الحالة بعد إنشاء حدث جديد (محاكاة تحديث في الوقت الفعلي)
        const currentEvents = this.eventsSubject.value;
        this.eventsSubject.next([...currentEvents, newEvent]);
      }),
      catchError(this.handleError)
    );
  }

  // دالة إضافية لمحاكاة تحديث في الوقت الفعلي (Real-time update)
  // في التطبيق الحقيقي، سيتم استدعاء هذه الدالة من داخل معالج رسائل WebSocket
  public pushRealTimeUpdate(newEvent: TimelineEvent): void {
    console.log('Real-time update received:', newEvent);
    const currentEvents = this.eventsSubject.value;
    this.eventsSubject.next([newEvent, ...currentEvents]); // إضافة الحدث الجديد في البداية
  }

  /**
   * دالة إضافية للوصول إلى الحالة الحالية بشكل مباشر (للقراءة فقط)
   * @returns مصفوفة الأحداث الحالية
   */
  public getCurrentEvents(): TimelineEvent[] {
    return this.eventsSubject.value;
  }
}
