import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { BehaviorSubject, Observable, throwError } from 'rxjs';
import { catchError, tap, map } from 'rxjs/operators';

// تعريف واجهة للـ Sticky Note
interface StickyNote {
  id: string;
  content: string;
  x: number;
  y: number;
  color: string;
  createdAt: Date;
  updatedAt: Date;
}

@Injectable({
  providedIn: 'root'
})
export class StickyNotesService {
  private apiUrl = '/api/sticky-notes'; // نقطة نهاية افتراضية
  private notesSubject = new BehaviorSubject<StickyNote[]>([]);
  public notes$: Observable<StickyNote[]> = this.notesSubject.asObservable();

  constructor(private http: HttpClient) {
    // تحميل الملاحظات عند تهيئة الخدمة
    this.getAll().subscribe({
      error: (err) => console.error('Failed to load initial sticky notes:', err)
    });
  }

  private handleError(error: HttpErrorResponse) {
    console.error('An error occurred:', error.error instanceof ErrorEvent ? error.error.message : error.status);
    // يمكن إرسال الخطأ إلى خدمة تسجيل خارجية
    return throwError(() => new Error('Something bad happened; please try again later.'));
  }

  // 1. getAll: جلب جميع الملاحظات وتحديث الـ state
  getAll(): Observable<StickyNote[]> {
    return this.http.get<StickyNote[]>(this.apiUrl).pipe(
      tap(notes => this.notesSubject.next(notes)),
      catchError(this.handleError)
    );
  }

  // 2. create: إنشاء ملاحظة جديدة
  create(noteData: Omit<StickyNote, 'id' | 'createdAt' | 'updatedAt'>): Observable<StickyNote> {
    return this.http.post<StickyNote>(this.apiUrl, noteData).pipe(
      tap(newNote => {
        const currentNotes = this.notesSubject.value;
        this.notesSubject.next([...currentNotes, newNote]);
      }),
      catchError(this.handleError)
    );
  }

  // 3. getOne: جلب ملاحظة واحدة (لا يتم تحديث الـ state هنا)
  getOne(id: string): Observable<StickyNote> {
    const url = `${this.apiUrl}/${id}`;
    return this.http.get<StickyNote>(url).pipe(
      catchError(this.handleError)
    );
  }

  // 4. update: تحديث محتوى ملاحظة
  update(id: string, content: Partial<StickyNote>): Observable<StickyNote> {
    const url = `${this.apiUrl}/${id}`;
    return this.http.put<StickyNote>(url, content).pipe(
      tap(updatedNote => {
        const currentNotes = this.notesSubject.value.map(note =>
          note.id === id ? updatedNote : note
        );
        this.notesSubject.next(currentNotes);
      }),
      catchError(this.handleError)
    );
  }

  // 5. delete: حذف ملاحظة
  delete(id: string): Observable<void> {
    const url = `${this.apiUrl}/${id}`;
    return this.http.delete<void>(url).pipe(
      tap(() => {
        const currentNotes = this.notesSubject.value.filter(note => note.id !== id);
        this.notesSubject.next(currentNotes);
      }),
      catchError(this.handleError)
    );
  }

  // 6. updatePosition: تحديث موقع الملاحظة (x, y)
  updatePosition(id: string, x: number, y: number): Observable<StickyNote> {
    const url = `${this.apiUrl}/${id}/position`;
    return this.http.patch<StickyNote>(url, { x, y }).pipe(
      tap(updatedNote => {
        const currentNotes = this.notesSubject.value.map(note =>
          note.id === id ? { ...note, x: updatedNote.x, y: updatedNote.y } : note
        );
        this.notesSubject.next(currentNotes);
      }),
      catchError(this.handleError)
    );
  }

  // Method to get the current state synchronously (optional but useful)
  getCurrentNotes(): StickyNote[] {
    return this.notesSubject.value;
  }
}
