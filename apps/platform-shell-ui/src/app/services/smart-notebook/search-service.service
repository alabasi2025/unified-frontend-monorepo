import { Injectable } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { BehaviorSubject, Observable, Subject, throwError } from 'rxjs';
import {
  debounceTime,
  distinctUntilChanged,
  switchMap,
  catchError,
  tap,
} from 'rxjs/operators';

// تعريف واجهات للبيانات
interface SearchResult {
  type: 'global' | 'notebooks' | 'pages' | 'ideas' | 'tasks';
  results: any[];
}

interface SearchState {
  loading: boolean;
  error: string | null;
  globalResults: any[];
  notebooksResults: any[];
  pagesResults: any[];
  ideasResults: any[];
  tasksResults: any[];
}

@Injectable({
  providedIn: 'root',
})
export class SearchService {
  private apiUrl = '/api/search'; // مسار API الافتراضي
  private searchStateSubject = new BehaviorSubject<SearchState>({
    loading: false,
    error: null,
    globalResults: [],
    notebooksResults: [],
    pagesResults: [],
    ideasResults: [],
    tasksResults: [],
  });
  public searchState$ = this.searchStateSubject.asObservable();

  // Subject لإدارة الـ debounce
  private globalSearchTerms = new Subject<string>();
  private notebooksSearchTerms = new Subject<string>();
  private pagesSearchTerms = new Subject<string>();
  private ideasSearchTerms = new Subject<string>();
  private tasksSearchTerms = new Subject<string>();

  constructor(private http: HttpClient) {
    // إعداد الـ debounce لكل نوع بحث
    this.setupDebouncedSearch(
      this.globalSearchTerms,
      (term) => this.executeSearch('global', term)
    );
    this.setupDebouncedSearch(
      this.notebooksSearchTerms,
      (term) => this.executeSearch('notebooks', term)
    );
    this.setupDebouncedSearch(
      this.pagesSearchTerms,
      (term) => this.executeSearch('pages', term)
    );
    this.setupDebouncedSearch(
      this.ideasSearchTerms,
      (term) => this.executeSearch('ideas', term)
    );
    this.setupDebouncedSearch(
      this.tasksSearchTerms,
      (term) => this.executeSearch('tasks', term)
    );
  }

  private setupDebouncedSearch(
    terms: Subject<string>,
    searchFn: (term: string) => Observable<any>
  ): void {
    terms
      .pipe(
        debounceTime(300), // انتظار 300 مللي ثانية بعد آخر ضغطة مفتاح
        distinctUntilChanged(), // تجاهل البحث إذا كان نفس المصطلح
        tap(() => this.updateState({ loading: true, error: null })),
        switchMap((term: string) => {
          if (!term.trim()) {
            // إذا كان المصطلح فارغًا، قم بإرجاع Observable فارغ
            return new Observable<any>((observer) => {
              observer.next([]);
              observer.complete();
            });
          }
          return searchFn(term).pipe(
            catchError((err) => {
              this.handleError(err);
              return throwError(() => err);
            })
          );
        })
      )
      .subscribe((results: SearchResult) => {
        this.updateState({ loading: false });
        this.updateResults(results.type, results.results);
      });
  }

  private updateState(newState: Partial<SearchState>): void {
    this.searchStateSubject.next({ ...this.searchStateSubject.value, ...newState });
  }

  private updateResults(type: SearchResult['type'], results: any[]): void {
    const currentState = this.searchStateSubject.value;
    let update: Partial<SearchState> = {};

    switch (type) {
      case 'global':
        update = { globalResults: results };
        break;
      case 'notebooks':
        update = { notebooksResults: results };
        break;
      case 'pages':
        update = { pagesResults: results };
        break;
      case 'ideas':
        update = { ideasResults: results };
        break;
      case 'tasks':
        update = { tasksResults: results };
        break;
    }

    this.updateState(update);
  }

  private executeSearch(
    type: SearchResult['type'],
    term: string
  ): Observable<SearchResult> {
    const url = `${this.apiUrl}/${type}?q=${term}`;
    return this.http.get<any[]>(url).pipe(
      // يجب أن يكون الـ API مصممًا لإرجاع مصفوفة من النتائج
      // نقوم بتغليفها هنا لتناسب واجهة SearchResult
      tap((results) => console.log(`Search for ${type} with term "${term}" completed.`)),
      switchMap((results) => {
        return new Observable<SearchResult>((observer) => {
          observer.next({ type, results });
          observer.complete();
        });
      })
    );
  }

  private handleError(error: HttpErrorResponse): void {
    let errorMessage = 'An unknown error occurred!';
    if (error.error instanceof ErrorEvent) {
      // خطأ من جانب العميل أو الشبكة
      errorMessage = `Error: ${error.error.message}`;
    } else {
      // خطأ من جانب الخادم
      errorMessage = `Server returned code: ${error.status}, error message: ${error.message}`;
    }
    console.error(errorMessage);
    this.updateState({ loading: false, error: errorMessage });
  }

  // -------------------------------------------------------------------
  // Public Search Methods (API for Components)
  // -------------------------------------------------------------------

  /**
   * يبدأ بحثًا شاملاً (Global Search) مع تطبيق debounce.
   * @param term مصطلح البحث.
   */
  globalSearch(term: string): void {
    this.globalSearchTerms.next(term);
  }

  /**
   * يبدأ بحثًا في الدفاتر (Notebooks) مع تطبيق debounce.
   * @param term مصطلح البحث.
   */
  searchNotebooks(term: string): void {
    this.notebooksSearchTerms.next(term);
  }

  /**
   * يبدأ بحثًا في الصفحات (Pages) مع تطبيق debounce.
   * @param term مصطلح البحث.
   */
  searchPages(term: string): void {
    this.pagesSearchTerms.next(term);
  }

  /**
   * يبدأ بحثًا في الأفكار (Ideas) مع تطبيق debounce.
   * @param term مصطلح البحث.
   */
  searchIdeas(term: string): void {
    this.ideasSearchTerms.next(term);
  }

  /**
   * يبدأ بحثًا في المهام (Tasks) مع تطبيق debounce.
   * @param term مصطلح البحث.
   */
  searchTasks(term: string): void {
    this.tasksSearchTerms.next(term);
  }

  /**
   * لإلغاء الاشتراك في جميع الـ Subjects عند تدمير الخدمة (اختياري).
   * يجب استدعاء هذه الدالة في ngOnDestroy إذا تم توفيرها في الخدمة.
   */
  // ngOnDestroy(): void {
  //   this.globalSearchTerms.complete();
  //   this.notebooksSearchTerms.complete();
  //   this.pagesSearchTerms.complete();
  //   this.ideasSearchTerms.complete();
  //   this.tasksSearchTerms.complete();
  // }
}
